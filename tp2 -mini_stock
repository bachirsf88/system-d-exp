// mini_stock_fixed.c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <string.h>

typedef struct {
    long *stock;
    long K;
    int mode;                 
    pthread_mutex_t lock;
    volatile int stop;        
    long sales_ok;
    long sales_refused;
} shop_t;

long rand_between(long a, long b) {
    return a + rand() % (b - a + 1);
}

/* ===== Thread caisse ===== */
void* cashier(void* arg) {
    shop_t *s = (shop_t*)arg;

    while (!s->stop) {
        int item = rand() % s->K;
        long qty = rand_between(1, 3);

        if (s->mode == 0) {
            // MODE NAÏF
            if (s->stock[item] >= qty) {
                s->stock[item] -= qty;
                s->sales_ok++;
            } else {
                s->sales_refused++;
            }
        } else {
            // MODE MUTEX GLOBAL
            pthread_mutex_lock(&s->lock);
            if (s->stock[item] >= qty) {
                s->stock[item] -= qty;
                s->sales_ok++;
            } else {
                s->sales_refused++;
            }
            pthread_mutex_unlock(&s->lock);
        }
        usleep(100);
    }
    return NULL;
}

/* ===== Thread réassort ===== */
void* restocker(void* arg) {
    shop_t *s = (shop_t*)arg;

    while (!s->stop) {
        int item = rand() % s->K;
        long add = rand_between(1, 5);

        if (s->mode == 0) {
            s->stock[item] += add;
        } else {
            pthread_mutex_lock(&s->lock);
            s->stock[item] += add;
            pthread_mutex_unlock(&s->lock);
        }
        sleep(1);
    }
    return NULL;
}

int main() {
    /* ===== Valeurs fixes (ONLINE) ===== */
    long K = 5;     // articles
    int T = 3;      // caisses
    int D = 8;      // durée (secondes)
    int mode = 1;   // 0 = naive, 1 = global mutex

    srand(time(NULL));

    shop_t s;
    s.K = K;
    s.mode = mode;
    s.stop = 0;
    s.sales_ok = 0;
    s.sales_refused = 0;

    s.stock = malloc(K * sizeof(long));
    for (long i = 0; i < K; i++)
        s.stock[i] = 10;

    pthread_mutex_init(&s.lock, NULL);

    pthread_t *cashiers = malloc(T * sizeof(pthread_t));
    pthread_t rest;

    for (int i = 0; i < T; i++)
        pthread_create(&cashiers[i], NULL, cashier, &s);

    pthread_create(&rest, NULL, restocker, &s);

    printf("Mini-stock (%s) | K=%ld | T=%d | D=%d\n",
           mode ? "mutex global" : "naive", K, T, D);

    sleep(D);
    s.stop = 1;

    for (int i = 0; i < T; i++)
        pthread_join(cashiers[i], NULL);
    pthread_join(rest, NULL);

    printf("\nStock final:\n");
    long total = 0;
    for (long i = 0; i < K; i++) {
        printf("Article %ld : %ld\n", i, s.stock[i]);
        total += s.stock[i];
    }

    printf("\nVentes OK = %ld\n", s.sales_ok);
    printf("Ventes refusées = %ld\n", s.sales_refused);
    printf("Stock total = %ld\n", total);

    return 0;
}
